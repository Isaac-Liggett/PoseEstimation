{% extends 'base.html' %}

{% block title %}Monitor{% endblock %}

{% block content %}
<style>
  .monitor-layout {
    display: grid;
    grid-template-columns: 1fr 340px;
    gap: 16px;
  }

  .stage {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  #viewport {
    position: relative;
    width: 100%;
    height: 60vh;
    background: #000;
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: inset 0 0 40px rgba(0, 0, 0, .35);
  }

  .hud {
    position: absolute;
    inset: 10px auto auto 10px;
    display: flex;
    gap: 8px;
    align-items: center;
    pointer-events: none;
  }

  .badge.rec {
    background: #2a0e12;
    border: 1px solid #b02a2a;
    color: #fd645c;
  }

  .hidden {
    display: none;
  }

  .controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .btn.danger {
    background: linear-gradient(135deg, #ff5757, #ff2a2a);
    border-color: #c02020;
    color: #fff;
  }

  .grow {
    flex: 1 1 auto;
  }

  .timeline {
    background: #0d131a;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px 12px;
  }

  .timeline input[type="range"] {
    width: 100%;
  }

  .timebar {
    display: flex;
    justify-content: space-between;
    margin-top: 6px;
    color: var(--muted);
  }

  .sidebar .sidecard {
    background: #0f141b;
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 12px;
    margin-bottom: 16px;
  }

  .sidebar h3 {
    margin: 0 0 8px 0;
  }

  .sidebar .video {
    width: 19rem;
    height: 10.6875rem;
    /* aspect-ratio: 16/9; */
    border-radius: 10px;
    border: 1px solid var(--border);
    background: #000;
    margin-bottom: 10px;
  }

  @media (max-width:980px) {
    .monitor-layout {
      grid-template-columns: 1fr;
    }
  }
</style>

<div class="monitor-layout">
  <!-- LEFT: stage -->
  <div class="stage">
    <div id="viewport">
      <div class="hud">
        <span id="recBadge" class="badge rec hidden">● REC</span>
        <span class="badge"><span id="timer">00:00.0</span></span>
        <span class="badge">FPS <span id="fps">—</span></span>
      </div>
    </div>

    <div class="controls">
      <button class="btn danger" id="btnRecord">● Record</button>
      <button class="btn" id="btnPause" disabled>Pause</button>
      <button class="btn" id="btnStop" disabled>Stop</button>
      <div class="grow"></div>
      <button class="btn" id="btnPlay">Play</button>
      <button class="btn" id="btnExport">Export</button>
    </div>

    <div class="timeline">
      <input type="range" id="seek" min="0" max="15000" step="10" value="0" />
      <div class="timebar">
        <span id="cur">00:00.0</span>
        <span id="dur">00:15.0</span>
      </div>
    </div>
  </div>

  <!-- RIGHT: cameras + rig controls -->
  <div class="sidebar">
    <div class="sidecard">
      <h3>Cameras</h3>
      <div id="videos-container"></div>
      <div class="row" style="display:flex; gap:8px;">
        <button class="btn" id="connectCams">Connect</button>
        <button class="btn" id="flipCams">Flip</button>
      </div>
    </div>

    <div class="sidecard">
      <h3>Rig &amp; Animation</h3>
      <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn" id="loadRig">Load Rig</button>
        <button class="btn" id="loadIdle">Idle</button>
        <button class="btn" id="loadWalk">Walk</button>
        <button class="btn" id="animPlay">Play</button>
        <button class="btn" id="animPause">Pause</button>
        <button class="btn" id="animReset">Reset</button>
      </div>
      <small class="muted">Files: <code>/static/models/mixamo_character.fbx</code>, <code>Idle.fbx</code>,
        <code>Walking.fbx</code></small>
    </div>

    <div class="sidecard">
      <h3>Tips</h3>
      <ul class="muted" style="margin:0; padding-left:18px; line-height:1.6;">
        <li>Press <b>R</b> to start/stop recording.</li>
        <li>Press <b>Space</b> to pause/resume.</li>
        <li>Drag the timeline to scrub.</li>
      </ul>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<!-- UI controls (record/pause/stop) -->
<script>
  console.log("monitor: plain script loaded");
  const btnRecord = document.getElementById('btnRecord');
  const btnPause = document.getElementById('btnPause');
  const btnStop = document.getElementById('btnStop');
  const btnPlay = document.getElementById('btnPlay');

  const recBadge = document.getElementById('recBadge');
  const timerEl = document.getElementById('timer');
  const curEl = document.getElementById('cur');
  const durEl = document.getElementById('dur');
  const seek = document.getElementById('seek');

  let state = 'idle', startMs = 0, totalMs = 0, tick;
  const fmt = (ms) => { const s = ms / 1000, m = Math.floor(s / 60), r = (s - m * 60).toFixed(1).padStart(4, '0'); return `${String(m).padStart(2, '0')}:${r}`; };
  function setState(n) { state = n; const recLike = (n === 'recording' || n === 'paused'); btnPause.disabled = !recLike; btnStop.disabled = !recLike; recBadge.classList.toggle('hidden', n !== 'recording'); btnPause.textContent = n === 'paused' ? 'Resume' : 'Pause'; btnRecord.textContent = n === 'recording' ? '● Recording' : '● Record'; }
  function tickStart() { clearInterval(tick); tick = setInterval(() => { let e = totalMs; if (state === 'recording') e += performance.now() - startMs; timerEl.textContent = fmt(e); if (state !== 'recording') return; seek.max = Math.max(seek.max, Math.round(e)); seek.value = Math.round(e); curEl.textContent = fmt(+seek.value); durEl.textContent = fmt(+seek.max); }, 50); }
  btnRecord.addEventListener('click', () => { if (state === 'idle' || state === 'playback') { totalMs = 0; startMs = performance.now(); setState('recording'); tickStart(); } });
  btnPause.addEventListener('click', () => { if (state === 'recording') { totalMs += performance.now() - startMs; setState('paused'); } else if (state === 'paused') { startMs = performance.now(); setState('recording'); } });
  btnStop.addEventListener('click', () => { if (state === 'recording') totalMs += performance.now() - startMs; clearInterval(tick); setState('playback'); seek.max = totalMs || 1; seek.value = 0; curEl.textContent = fmt(0); durEl.textContent = fmt(totalMs); timerEl.textContent = fmt(totalMs); });
  seek.addEventListener('input', () => { if (state === 'playback' || state === 'paused') curEl.textContent = fmt(+seek.value); });
  window.addEventListener('keydown', (e) => { if (/^(INPUT|TEXTAREA)$/.test(e.target.tagName)) return; if (e.code === 'KeyR') { btnRecord.click(); e.preventDefault(); } if (e.code === 'Space') { btnPause.click(); e.preventDefault(); } });

  // FPS HUD
  const fpsEl = document.getElementById('fps'); let frames = 0, last = performance.now();
  setInterval(() => { frames++; const now = performance.now(); if (now - last >= 1000) { fpsEl.textContent = String(frames); frames = 0; last = now; } }, 16);

  // Local camera preview (safe no-op if elements aren’t present)
  const connect = document.getElementById('connectCams'), flip = document.getElementById('flipCams');
  let facing = 'environment', cam1 = document.getElementById('cam1'), cam2 = document.getElementById('cam2');
  connect?.addEventListener('click', async () => { if (!cam1 || !cam2) return; try { const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facing }, audio: false }); cam1.srcObject = stream; cam2.srcObject = stream; } catch (err) { alert('Camera error: ' + err); } });
  flip?.addEventListener('click', () => { facing = (facing === 'user') ? 'environment' : 'user'; connect?.click(); });
</script>

<!-- IMPORT MAP: lets example modules resolve "three" -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
  }
}
</script>

<!-- Three.js (CDN) — rig + animation -->
<script type="module">
  console.log('monitor: CDN rig script start');

  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

  let scene, camera, renderer, controls, clock;
  let model, mixer, currentAction;
  const boneMap = {};

  // --- debug helpers (visible from DevTools) ---
  window.listBones = () => Object.keys(boneMap).sort();
  window.findBone  = (n) => boneMap[n?.toLowerCase().replace(/^mixamorig:*/, '').replace(/[^a-z]/g,'')];
  window.showBones = () => console.table(Object.keys(boneMap).sort());


  function initThree() {
    const container = document.getElementById('viewport');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(1.6, 1.8, 3.2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.1, 0);

    clock = new THREE.Clock();

    scene.add(new THREE.AxesHelper(0.5));
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222244, 1.2));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3, 5, 2); scene.add(dir);

    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(1.0, 64),
      new THREE.MeshStandardMaterial({ color: 0x1b2330, metalness: 0.1, roughness: 0.9 })
    );
    floor.rotation.x = -Math.PI / 2; floor.position.y = 0; scene.add(floor);

    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    (function loop() { requestAnimationFrame(loop); const dt = clock.getDelta(); if (mixer) mixer.update(dt); controls.update(); renderer.render(scene, camera); })();
  }

  function simplify(n) { return n.toLowerCase().replace(/^mixamorig:*/, '').replace(/[^a-z]/g, ''); }
  function buildBoneMap(root) {
  for (const k of Object.keys(boneMap)) delete boneMap[k];
  root.traverse(o => { if (o.isBone) boneMap[simplify(o.name)] = o; });
  console.log('[bones]', Object.keys(boneMap).sort()); // quick glance
}

  function loadCharacter(path) {
    const loader = new FBXLoader();
    loader.load(path, (fbx) => {
      if (model) scene.remove(model);
      model = fbx;
      model.scale.setScalar(0.01); // Mixamo units
      scene.add(model);
      mixer = new THREE.AnimationMixer(model);
      buildBoneMap(model);
      captureBind();
      console.log('[bind keys]', Object.keys(BIND));
      currentAction = null;
      console.log('Character loaded');
    }, undefined, (e) => console.error('Character load error', e));
  }


  function loadAnimation(path) {
    if (!model) { alert('Load the rig first.'); return; }
    const loader = new FBXLoader();
    loader.load(path, (anim) => {
      const clip = anim?.animations?.[0];
      if (!clip) { alert('No animation in file.'); return; }
      if (currentAction) currentAction.stop();
      currentAction = mixer.clipAction(clip);
      currentAction.reset().play();
      currentAction.paused = false;
      console.log('Animation loaded:', clip.name || path);
    }, undefined, (e) => console.error('Animation load error', e));
  }

  function initializeScene() {
    if (!scene) initThree();
    loadCharacter('/static/models/mixamo_character.fbx');
  }

  // Button bindings
  document.getElementById('loadRig').addEventListener('click', () => {
    initializeScene();
  });
  document.getElementById('loadIdle').addEventListener('click', () => loadAnimation('/static/models/Idle.fbx'));
  document.getElementById('loadWalk').addEventListener('click', () => loadAnimation('/static/models/Walking.fbx'));
  document.getElementById('animPlay').addEventListener('click', () => { if (currentAction) currentAction.paused = false; });
  document.getElementById('animPause').addEventListener('click', () => { if (currentAction) currentAction.paused = true; });
  document.getElementById('animReset').addEventListener('click', () => { if (currentAction) currentAction.reset(); });
  document.getElementById('btnPlay').addEventListener('click', () => { if (currentAction) currentAction.paused = false; });

  console.log('monitor: CDN rig script ready');

  // ---- Pose bridge (drop-in) ----
  const PoseBridge = (() => {
    const listeners = new Set();
    return {
      on(fn) { listeners.add(fn); return () => listeners.delete(fn); },
      emit(fr) { for (const fn of listeners) fn(fr); },
      // simple test generator (press G in browser console to start/stop)
      _mock(start = true) {
        if (start) {
          let t = 0;
          this._timer = setInterval(() => {
            // very rough sine-wave elbows/knees; replace with file/playback if you like
            const L = Array.from({ length: 33 }, () => ({ x: 0, y: 0, z: 0, v: 1 }));
            const hipL = 23, hipR = 24, shL = 11, shR = 12, elL = 13, elR = 14, wrL = 15, wrR = 16, knL = 25, knR = 26, anL = 27, anR = 28;
            // base T-pose-ish scaffold
            L[hipL] = { x: -0.1, y: -0.5, z: 0, v: 1 }; L[hipR] = { x: 0.1, y: -0.5, z: 0, v: 1 };
            L[shL] = { x: -0.2, y: 0.1, z: 0, v: 1 }; L[shR] = { x: 0.2, y: 0.1, z: 0, v: 1 };
            L[elL] = { x: -0.35, y: 0.0 + 0.05 * Math.sin(t), z: 0, v: 1 };
            L[elR] = { x: 0.35, y: 0.0 - 0.05 * Math.sin(t), z: 0, v: 1 };
            L[wrL] = { x: -0.5, y: 0.0 + 0.08 * Math.sin(t), z: 0, v: 1 };
            L[wrR] = { x: 0.5, y: 0.0 - 0.08 * Math.sin(t), z: 0, v: 1 };
            L[knL] = { x: -0.08, y: -0.95 + 0.05 * Math.sin(t * 0.7), z: 0, v: 1 };
            L[knR] = { x: 0.08, y: -0.95 - 0.05 * Math.sin(t * 0.7), z: 0, v: 1 };
            L[anL] = { x: -0.08, y: -1.2, z: 0, v: 1 };
            L[anR] = { x: 0.08, y: -1.2, z: 0, v: 1 };
            PoseBridge.emit({ t: performance.now() / 1000, source: "mock", space: "world", landmarks: L });
            t += 0.08;
          }, 33);
        } else { clearInterval(this._timer); }
      }
    };
  })();
  window.PoseBridge = PoseBridge; // for easy access in console

  // ===== PUBLIC API your teammate will call =====

  // 1) Send BlazePose 33 landmarks (either array of {x,y,z,visibility?} OR flat array length 99)
  // REPLACE your window.updatePose33 with this version
window.updatePose33 = function updatePose33(landmarks, space = 'world') {
  // live badge + debug
  if (!window.__poseCount) window.__poseCount = 0;
  window.__poseCount++;
  if (window.__poseCount % 10 === 1) {
    console.log('[POSE] frames', window.__poseCount, 'shape',
      Array.isArray(landmarks) && landmarks[0] && typeof landmarks[0] === 'object'
        ? 'objects'
        : Array.isArray(landmarks) && Array.isArray(landmarks[0])
          ? 'array-of-arrays'
          : 'flat');
  }
  const badge = document.getElementById('recBadge');
  if (badge) { badge.classList.remove('hidden'); badge.textContent = '● LIVE'; }

  let L;

  // A) [{x,y,z,visibility?}, ...]
  if (Array.isArray(landmarks) && typeof landmarks[0] === 'object' && !Array.isArray(landmarks[0])) {
    L = landmarks.map(p => ({
      x: +p.x || 0,
      y: +p.y || 0,
      z: +p.z || 0,
      v: p.visibility ?? p.v ?? 1
    }));
  }
  // B) [[x,y,z], ...]  <-- your teammate’s format
  else if (Array.isArray(landmarks) && Array.isArray(landmarks[0])) {
    L = landmarks.map(a => ({
      x: +a[0] || 0,
      y: +a[1] || 0,
      z: +a[2] || 0,
      v: (a[3] ?? 1)
    }));
  }
  // C) [x0,y0,z0, x1,y1,z1, ...] length 99
  else {
    const a = landmarks;
    L = Array.from({ length: 33 }, (_, i) => ({
      x: +a[i * 3 + 0] || 0,
      y: +a[i * 3 + 1] || 0,
      z: +a[i * 3 + 2] || 0,
      v: 1
    }));
  }

  // ✅ DO NOT call updatePose33 again here.
  // Hand the frame to the retargeter:
  PoseBridge.emit({
    t: performance.now() / 1000,
    source: 'live',
    space,            // 'world' for your numeric coords; use 'normalized_image' if 0..1 with Y-down
    landmarks: L
  });
};


  // 2) Helper if your teammate has pixel coords (x,y in pixels, z optional)
  window.updatePose33Pixels = function updatePose33Pixels(pointsPx, width, height) {
    const L = pointsPx.map(p => {
      const x = p[0] / width;
      const y = p[1] / height;
      const z = (p[2] ?? 0);
      const v = (p[3] ?? 1);
      return { x, y, z, v };
    });
    window.updatePose33(L, 'world');
  };

  // 3) Stop live driving (so Idle/Walk buttons work again)
  window.stopLivePose = function stopLivePose() {
    PoseBridge._mock(false); // ensure mock is off if it was running
    // Just stop calling updatePose33; the rig will stay on the last pose
  };

const AXIS = {
  MIRROR_X : true,   // set true if left/right is swapped
  FLIP_Y   : false,    // true if your world has Y-down (most CV outputs)
  FLIP_Z   : true,    // true if your world has +Z toward camera
};

function normalizeBlazePose(L, space='world'){
  const V = L.map(p => ({x:+p.x||0, y:+p.y||0, z:+p.z||0, v:p.v??p.visibility??1}));

  // axis fixes for 'world'
  if (space === 'world') {
    for (const p of V){
      if (AXIS.MIRROR_X) p.x = -p.x;
      if (AXIS.FLIP_Y)   p.y = -p.y;
      if (AXIS.FLIP_Z)   p.z = -p.z;
    }
  } else if (space === 'normalized_image') {
    for (const p of V){ p.y = -p.y; p.z = -p.z; } // what you already had
  }

  const to = (i)=>new THREE.Vector3(V[i].x,V[i].y,V[i].z);
  let hipL = to(23), hipR = to(24);
  let root = hipL.clone().add(hipR).multiplyScalar(0.5);
  let scale = hipL.distanceTo(hipR);

  // fallback if hips are dodgy
  if (!isFinite(scale) || scale < 1e-3 || scale > 1e6) {
    const shL = to(11), shR = to(12);
    root  = shL.clone().add(shR).multiplyScalar(0.5);
    scale = shL.distanceTo(shR) || 1.0;
  }

  return V.map(p => {
    const v = new THREE.Vector3(p.x,p.y,p.z).sub(root).divideScalar(scale);
    return { v, conf: p.v ?? 1 };
  });
}


// --- Retarget mapping (BlazePose 33 -> Mixamo/YBot w/ virtual joints) ---
// Use numbers for BlazePose indices, or strings for virtual points defined below
const DRIVEN = {
  // Torso
 // spine:      ['midhip', 'midshoulder'],  // pelvis -> shoulder center
 // neck:       ['midshoulder', 'headbase'],// shoulder center -> head base
//  head:       ['headbase', 0],            // head base -> nose (0)

  // Arms
  leftarm:      [11, 13],
  leftforearm:  [13, 15],
  rightarm:     [12, 14],
  rightforearm: [14, 16],

  // Hands  (wrist -> index fingertip approx)
  //lefthand:   [15, 19],
  righthand:  [16, 20],

  // Legs
  leftupleg:  [23, 25],
  leftleg:    [25, 27],
  rightupleg: [24, 26],
  rightleg:   [26, 28],

  // Feet  (ankle -> foot index)
  //leftfoot:   [27, 31],
  rightfoot:  [28, 32],
};

const BIND = {}; // boneName -> {dir: Vector3, worldRot: Quaternion}

// Which bone to look-at for each driven bone (fallbacks to 1st child if missing)
const TIP = {
  // torso
  spine:       'neck',
  neck:        'head',
  head:        'headtopend',

  // arms
  leftarm:      'leftforearm',
  leftforearm:  'lefthand',
  lefthand:     'lefthandmiddle',   // or 'lefthandindex'

  rightarm:     'rightforearm',
  rightforearm: 'righthand',
  righthand:    'righthandmiddle',  // or 'righthandindex'

  // legs
  leftupleg:    'leftleg',
  leftleg:      'leftfoot',
  leftfoot:     'lefttoebase',

  rightupleg:   'rightleg',
  rightleg:     'rightfoot',
  rightfoot:    'righttoebase',
};


// Capture bind pose once (direction & world rotation)
function captureBind() {
  // clear previous
  for (const k in BIND) delete BIND[k];

  const a = new THREE.Vector3(), b = new THREE.Vector3(), q = new THREE.Quaternion();
  let created = 0;

  for (const name in DRIVEN) {
    const boneA = boneMap[name];
    if (!boneA) { console.warn('[bind] missing bone', name); continue; }

    // prefer named tip, else first bone child
    const tipName = TIP[name];
    let boneB = (tipName && boneMap[tipName]) ? boneMap[tipName] : null;
    if (!boneB) {
      boneB = (boneA.children || []).find(c => c.isBone) || null;
    }
    if (!boneB) { console.warn('[bind] no tip/child for', name); continue; }

    boneA.getWorldPosition(a);
    boneB.getWorldPosition(b);
    const dir = b.clone().sub(a);
    const len = dir.length();
    if (!(len > 1e-6) || !isFinite(len)) { console.warn('[bind] zero len', name); continue; }
    dir.divideScalar(len);

    boneA.getWorldQuaternion(q);
    BIND[name] = { dir, worldRot: q.clone() };
    created++;
  }

  console.log('[bind] created for', created, 'bones');
  console.log('[bind]', Object.keys(BIND));

}


// Helpers for virtual points
const _mid = (v1, v2) => v1.clone().add(v2).multiplyScalar(0.5);

// Apply pose frame to skeleton (supports virtual points)
function applyBlazePoseFrame(frame) {
  console.log('[frame]', frame.space,
  'L11', frame.landmarks[11], 'L13', frame.landmarks[13],
  'L23', frame.landmarks[23], 'L24', frame.landmarks[24]);
  if (!model) return;

  // Normalize incoming pose to avatar-centric space
  const L = normalizeBlazePose(frame.landmarks, frame.space);

  if (!window.__dbg || (Date.now()-window.__dbg)>500) {
  window.__dbg = Date.now();
  const dHip = L[23].v.distanceTo(L[24].v).toFixed(3);
  const dLU  = L[11].v.distanceTo(L[13].v).toFixed(3);
  const dRU  = L[12].v.distanceTo(L[14].v).toFixed(3);
  console.log('[dist] hip-hip', dHip, 'Lshoulder-elbow', dLU, 'Rshoulder-elbow', dRU);
}


  // Build virtual points used by DRIVEN
  const v = (i) => L[i].v;
  const P = {
    midhip:       _mid(v(23), v(24)),
    midshoulder:  _mid(v(11), v(12)),
    headbase:     _mid(v(7),  v(8)),    // between ears; fallback: _mid(v(2), v(5)) for eyes
  };

  // Resolve either a numeric index or a virtual point name
  const get = (id) => (typeof id === 'number') ? v(id) : P[id];

  const SMOOTH = 1.0;
  let updates = 0; // <-- NEW: Count how many bones were updated

  for (const name in DRIVEN) {
  const bone = boneMap[name];
  const bind = BIND[name];

  const [fromId, toId] = DRIVEN[name];
  const from = typeof fromId === 'number' ? L[fromId]?.v : P[fromId];
  const to   = typeof toId   === 'number' ? L[toId]?.v   : P[toId];

  if (!bone || !bind) {
    console.warn('skip: no bind', name);
    continue;
  }
  if (!from || !to) {
    console.warn('skip: missing pts', name, fromId, toId);
    continue;
  }

  const dir = to.clone().sub(from);
  const len = dir.length();
  if (!(len > 1e-6) || !isFinite(len)) {
    console.warn('skip: bad len', name, len);
    continue;
  }

  dir.divideScalar(len); // normalize safely

  const delta    = new THREE.Quaternion().setFromUnitVectors(bind.dir, dir);
  const worldNew = delta.clone().multiply(bind.worldRot);
  const parentWorld = new THREE.Quaternion();
  bone.parent.getWorldQuaternion(parentWorld);
  const localNew = parentWorld.invert().multiply(worldNew);

  bone.quaternion.copy(localNew); // for debugging use full copy (no slerp)
  updates++;

  console.log('[retarget] bones updated:', updates);
}


  // Log once per second (frame.t is in seconds)
  if ((Math.floor(frame.t * 10) % 10) === 0) {
    console.log('[retarget] bones updated:', updates);
  }
}



  // Subscribe to pose stream
  PoseBridge.on((frame) => {
    if (currentAction) { currentAction.stop(); currentAction = null; }
    applyBlazePoseFrame(frame);
  });

  initializeScene();
</script>

<!-- WebRTC camera tiles (from your relay) -->
<script>
  const webrtc_url = "{{ webrtcurl }}";
  const wrap = document.getElementById('videos-container');

  // Helper function to create a canvas and associated hidden MJPEG img
  function createVideoCanvas(cam) {
    // Canvas element
    const canvas = document.createElement('canvas');
    canvas.className = 'video';

    // Hidden img to load MJPEG stream
    const img = document.createElement('img');
    img.src = `${webrtc_url}/view?cam=${cam}`;
    img.style.display = 'none';

    const ctx = canvas.getContext('2d');

    // Draw frames continuously
    img.onload = function drawFrame() {
      // Resize canvas to match img aspect ratio
      const containerWidth = wrap.clientWidth / 2; // half width for two streams
      const scale = containerWidth / img.naturalWidth;
      canvas.width = img.naturalWidth * scale;
      canvas.height = img.naturalHeight * scale;

      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      requestAnimationFrame(drawFrame);
    };

    wrap.appendChild(canvas);
    document.body.appendChild(img); // hidden, still needs to load frames
  }

  // Create two canvases for cam1 and cam2
  createVideoCanvas('cam1');
  createVideoCanvas('cam2');
</script>
<script>
  async function initMonitor() {
    const pc = new RTCPeerConnection();

    // Create skeleton data channel on browser
    const skeletonChannel = pc.createDataChannel("skeleton");
    skeletonChannel.onopen = () => {
      console.log("Data channel open");
    }
    skeletonChannel.onmessage = (ev) => {
<<<<<<< HEAD
      const raw = JSON.parse(ev.data); // raw = [[x,y,z], ...]
      const data = raw["points"];
      // console.log(data);

      // Convert to {x,y,z,v} objects
      const landmarks = data.map(p => ({
        x: p[0],
        y: p[1],
        z: p[2],
        v: 1
      }));

      // Fill in 33rd landmark if missing (optional)
      if (landmarks.length < 33) landmarks.push({ x: 0, y: 0, z: 0, v: 0 });

      // Feed into PoseBridge
      PoseBridge.emit({
        t: performance.now() / 1000,
        source: "live",
        space: "normalized_image",  // depends on how your data is scaled
        landmarks: landmarks
      });

    };
=======
  try {
    const raw = JSON.parse(ev.data);
    const pts = raw.points || raw;   // support both {points:[...]} or [...]
    updatePose33(pts, 'world'); // or 'world' depending on your data
  } catch (e) {
    console.error('pose msg parse error', e);
  }
};
>>>>>>> d2ac8eddf8c7c7f0ee8daa36408146f27565b907

    // Gather ICE candidates
    const candidates = [];
    pc.onicecandidate = (event) => {
      if (event.candidate) candidates.push(event.candidate);
    };

    // Create offer and send to server
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const resp = await fetch(`${webrtc_url}/monitor_offer`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(pc.localDescription)
    });
    const answer = await resp.json();
    await pc.setRemoteDescription(answer);
  }

  initMonitor();
</script>


{% endblock %}