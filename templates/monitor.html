{% extends 'base.html' %}

{% block title %}Monitor{% endblock %}

{% block content %}
<style>
  .monitor-layout { display:grid; grid-template-columns: 1fr 340px; gap:16px; }
  .stage { display:flex; flex-direction:column; gap:12px; }

  #viewport {
    position:relative; width:100%; height:60vh; background:#000;
    border:1px solid var(--border); border-radius:12px;
    box-shadow: inset 0 0 40px rgba(0,0,0,.35);
  }
  .hud { position:absolute; inset:10px auto auto 10px; display:flex; gap:8px; align-items:center; pointer-events:none; }
  .badge.rec { background:#2a0e12; border:1px solid #b02a2a; color:#fd645c; }
  .hidden { display:none; }

  .controls { display:flex; gap:8px; align-items:center; }
  .btn.danger { background:linear-gradient(135deg,#ff5757,#ff2a2a); border-color:#c02020; color:#fff; }
  .grow { flex:1 1 auto; }

  .timeline { background:#0d131a; border:1px solid var(--border); border-radius:10px; padding:10px 12px; }
  .timeline input[type="range"] { width:100%; }
  .timebar { display:flex; justify-content:space-between; margin-top:6px; color:var(--muted); }

  .sidebar .sidecard {
    background:#0f141b; border:1px solid var(--border);
    border-radius:14px; padding:12px; margin-bottom:16px;
  }
  .sidebar h3 { margin:0 0 8px 0; }
  .sidebar .video { width:100%; aspect-ratio:16/9; border-radius:10px; border:1px solid var(--border); background:#000; margin-bottom:10px; }

  @media (max-width:980px){ .monitor-layout{ grid-template-columns:1fr; } }
</style>

<div class="monitor-layout">
  <!-- LEFT: stage -->
  <div class="stage">
    <div id="viewport">
      <div class="hud">
        <span id="recBadge" class="badge rec hidden">● REC</span>
        <span class="badge"><span id="timer">00:00.0</span></span>
        <span class="badge">FPS <span id="fps">—</span></span>
      </div>
    </div>

    <div class="controls">
      <button class="btn danger" id="btnRecord">● Record</button>
      <button class="btn" id="btnPause" disabled>Pause</button>
      <button class="btn" id="btnStop" disabled>Stop</button>
      <div class="grow"></div>
      <button class="btn" id="btnPlay">Play</button>
      <button class="btn" id="btnExport">Export</button>
    </div>

    <div class="timeline">
      <input type="range" id="seek" min="0" max="15000" step="10" value="0" />
      <div class="timebar">
        <span id="cur">00:00.0</span>
        <span id="dur">00:15.0</span>
      </div>
    </div>
  </div>

  <!-- RIGHT: cameras + rig controls -->
  <div class="sidebar">
    <div class="sidecard">
      <h3>Cameras</h3>
      <div id="videos-container"></div>
      <div class="row" style="display:flex; gap:8px;">
        <button class="btn" id="connectCams">Connect</button>
        <button class="btn" id="flipCams">Flip</button>
      </div>
    </div>

    <div class="sidecard">
      <h3>Rig &amp; Animation</h3>
      <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn" id="loadRig">Load Rig</button>
        <button class="btn" id="loadIdle">Idle</button>
        <button class="btn" id="loadWalk">Walk</button>
        <button class="btn" id="animPlay">Play</button>
        <button class="btn" id="animPause">Pause</button>
        <button class="btn" id="animReset">Reset</button>
      </div>
      <small class="muted">Files: <code>/static/models/mixamo_character.fbx</code>, <code>Idle.fbx</code>, <code>Walking.fbx</code></small>
    </div>

    <div class="sidecard">
      <h3>Tips</h3>
      <ul class="muted" style="margin:0; padding-left:18px; line-height:1.6;">
        <li>Press <b>R</b> to start/stop recording.</li>
        <li>Press <b>Space</b> to pause/resume.</li>
        <li>Drag the timeline to scrub.</li>
      </ul>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<!-- UI controls (record/pause/stop) -->
<script>
  console.log("monitor: plain script loaded");
  const btnRecord = document.getElementById('btnRecord');
  const btnPause  = document.getElementById('btnPause');
  const btnStop   = document.getElementById('btnStop');
  const btnPlay   = document.getElementById('btnPlay');

  const recBadge  = document.getElementById('recBadge');
  const timerEl   = document.getElementById('timer');
  const curEl     = document.getElementById('cur');
  const durEl     = document.getElementById('dur');
  const seek      = document.getElementById('seek');

  let state='idle', startMs=0, totalMs=0, tick;
  const fmt = (ms)=>{ const s=ms/1000, m=Math.floor(s/60), r=(s-m*60).toFixed(1).padStart(4,'0'); return `${String(m).padStart(2,'0')}:${r}`; };
  function setState(n){ state=n; const recLike=(n==='recording'||n==='paused'); btnPause.disabled=!recLike; btnStop.disabled=!recLike; recBadge.classList.toggle('hidden',n!=='recording'); btnPause.textContent=n==='paused'?'Resume':'Pause'; btnRecord.textContent=n==='recording'?'● Recording':'● Record'; }
  function tickStart(){ clearInterval(tick); tick=setInterval(()=>{ let e=totalMs; if(state==='recording') e+=performance.now()-startMs; timerEl.textContent=fmt(e); if(state!=='recording') return; seek.max=Math.max(seek.max,Math.round(e)); seek.value=Math.round(e); curEl.textContent=fmt(+seek.value); durEl.textContent=fmt(+seek.max); },50); }
  btnRecord.addEventListener('click',()=>{ if(state==='idle'||state==='playback'){ totalMs=0; startMs=performance.now(); setState('recording'); tickStart(); }});
  btnPause.addEventListener('click',()=>{ if(state==='recording'){ totalMs+=performance.now()-startMs; setState('paused'); } else if(state==='paused'){ startMs=performance.now(); setState('recording'); }});
  btnStop.addEventListener('click',()=>{ if(state==='recording') totalMs+=performance.now()-startMs; clearInterval(tick); setState('playback'); seek.max=totalMs||1; seek.value=0; curEl.textContent=fmt(0); durEl.textContent=fmt(totalMs); timerEl.textContent=fmt(totalMs); });
  seek.addEventListener('input',()=>{ if(state==='playback'||state==='paused') curEl.textContent=fmt(+seek.value); });
  window.addEventListener('keydown',(e)=>{ if(/^(INPUT|TEXTAREA)$/.test(e.target.tagName)) return; if(e.code==='KeyR'){ btnRecord.click(); e.preventDefault(); } if(e.code==='Space'){ btnPause.click(); e.preventDefault(); }});

  // FPS HUD
  const fpsEl=document.getElementById('fps'); let frames=0, last=performance.now();
  setInterval(()=>{ frames++; const now=performance.now(); if(now-last>=1000){ fpsEl.textContent=String(frames); frames=0; last=now; }},16);

  // Local camera preview (safe no-op if elements aren’t present)
  const connect=document.getElementById('connectCams'), flip=document.getElementById('flipCams');
  let facing='environment', cam1=document.getElementById('cam1'), cam2=document.getElementById('cam2');
  connect?.addEventListener('click', async ()=>{ if(!cam1||!cam2) return; try{ const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:facing},audio:false}); cam1.srcObject=stream; cam2.srcObject=stream; }catch(err){ alert('Camera error: '+err); }});
  flip?.addEventListener('click', ()=>{ facing=(facing==='user')?'environment':'user'; connect?.click(); });
</script>

<!-- IMPORT MAP: lets example modules resolve "three" -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
  }
}
</script>



<!-- Three.js (CDN) — rig + animation -->
<script type="module">
  console.log('monitor: CDN rig script start');

  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

  let scene, camera, renderer, controls, clock;
  let model, mixer, currentAction;
  const boneMap = {};

  function initThree(){
    const container = document.getElementById('viewport');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 1000);
    camera.position.set(1.6, 1.8, 3.2);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.1, 0);

    clock = new THREE.Clock();

    scene.add(new THREE.AxesHelper(0.5));
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222244, 1.2));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3,5,2); scene.add(dir);

    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(1.0, 64),
      new THREE.MeshStandardMaterial({ color:0x1b2330, metalness:0.1, roughness:0.9 })
    );
    floor.rotation.x = -Math.PI/2; floor.position.y = 0; scene.add(floor);

    window.addEventListener('resize', ()=> {
      camera.aspect = container.clientWidth/container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    (function loop(){ requestAnimationFrame(loop); const dt=clock.getDelta(); if(mixer) mixer.update(dt); controls.update(); renderer.render(scene,camera); })();
  }

  function simplify(n){ return n.toLowerCase().replace(/^mixamorig:*/,'').replace(/[^a-z]/g,''); }
  function buildBoneMap(root){ for(const k of Object.keys(boneMap)) delete boneMap[k]; root.traverse(o=>{ if(o.isBone) boneMap[simplify(o.name)] = o; }); }

  function loadCharacter(path){
  const loader = new FBXLoader();
  loader.load(path, (fbx)=>{
    if(model) scene.remove(model);
    model = fbx;
    model.scale.setScalar(0.01); // Mixamo units
    scene.add(model);
    mixer = new THREE.AnimationMixer(model);
    buildBoneMap(model);
    captureBind(); // <--- ✅ ADD THIS LINE
    currentAction = null;
    console.log('Character loaded');
  }, undefined, (e)=>console.error('Character load error', e));
}


  function loadAnimation(path){
    if(!model){ alert('Load the rig first.'); return; }
    const loader = new FBXLoader();
    loader.load(path, (anim)=>{
      const clip = anim?.animations?.[0];
      if(!clip){ alert('No animation in file.'); return; }
      if(currentAction) currentAction.stop();
      currentAction = mixer.clipAction(clip);
      currentAction.reset().play();
      currentAction.paused = false;
      console.log('Animation loaded:', clip.name || path);
    }, undefined, (e)=>console.error('Animation load error', e));
  }

  // Button bindings
  document.getElementById('loadRig').addEventListener('click', ()=>{
    if(!scene) initThree();
    loadCharacter('/static/models/mixamo_character.fbx');
  });
  document.getElementById('loadIdle').addEventListener('click', ()=> loadAnimation('/static/models/Idle.fbx'));
  document.getElementById('loadWalk').addEventListener('click', ()=> loadAnimation('/static/models/Walking.fbx'));
  document.getElementById('animPlay').addEventListener('click',  ()=> { if(currentAction) currentAction.paused = false; });
  document.getElementById('animPause').addEventListener('click', ()=> { if(currentAction) currentAction.paused = true; });
  document.getElementById('animReset').addEventListener('click', ()=> { if(currentAction) currentAction.reset(); });
  document.getElementById('btnPlay').addEventListener('click',     ()=> { if(currentAction) currentAction.paused = false; });

  console.log('monitor: CDN rig script ready');

  // ---- Pose bridge (drop-in) ----
const PoseBridge = (() => {
  const listeners = new Set();
  return {
    on(fn)  { listeners.add(fn); return () => listeners.delete(fn); },
    emit(fr){ for (const fn of listeners) fn(fr); },
    // simple test generator (press G in browser console to start/stop)
    _mock(start=true){
      if (start) {
        let t=0;
        this._timer = setInterval(()=>{
          // very rough sine-wave elbows/knees; replace with file/playback if you like
          const L = Array.from({length:33},()=>({x:0,y:0,z:0,v:1}));
          const hipL=23, hipR=24, shL=11, shR=12, elL=13, elR=14, wrL=15, wrR=16, knL=25, knR=26, anL=27, anR=28;
          // base T-pose-ish scaffold
          L[hipL]={x:-0.1,y:-0.5,z:0,v:1}; L[hipR]={x:0.1,y:-0.5,z:0,v:1};
          L[shL]={x:-0.2,y:0.1,z:0,v:1};   L[shR]={x:0.2,y:0.1,z:0,v:1};
          L[elL]={x:-0.35,y:0.0+0.05*Math.sin(t),z:0,v:1};
          L[elR]={x: 0.35,y:0.0-0.05*Math.sin(t),z:0,v:1};
          L[wrL]={x:-0.5 ,y:0.0+0.08*Math.sin(t),z:0,v:1};
          L[wrR]={x: 0.5 ,y:0.0-0.08*Math.sin(t),z:0,v:1};
          L[knL]={x:-0.08,y:-0.95+0.05*Math.sin(t*0.7),z:0,v:1};
          L[knR]={x: 0.08,y:-0.95-0.05*Math.sin(t*0.7),z:0,v:1};
          L[anL]={x:-0.08,y:-1.2 ,z:0,v:1};
          L[anR]={x: 0.08,y:-1.2 ,z:0,v:1};
          PoseBridge.emit({t:performance.now()/1000, source:"mock", space:"normalized_image", landmarks:L});
          t += 0.08;
        }, 33);
      } else { clearInterval(this._timer); }
    }
  };
})();
window.PoseBridge = PoseBridge; // for easy access in console

// ===== PUBLIC API your teammate will call =====

// 1) Send BlazePose 33 landmarks (either array of {x,y,z,visibility?} OR flat array length 99)
window.updatePose33 = function updatePose33(landmarks, space = 'normalized_image') {
  let L;

  // A) landmarks = [{x,y,z,visibility?}, ... 33 items]
  if (Array.isArray(landmarks) && typeof landmarks[0] === 'object') {
    L = landmarks.map(p => ({
      x: +p.x || 0,
      y: +p.y || 0,
      z: +p.z || 0,
      v: p.visibility ?? p.v ?? 1
    }));
  } else {
    // B) landmarks = [x0,y0,z0, x1,y1,z1, ...] length 99
    const a = landmarks;
    L = Array.from({ length: 33 }, (_, i) => ({
      x: +a[i * 3 + 0] || 0,
      y: +a[i * 3 + 1] || 0,
      z: +a[i * 3 + 2] || 0,
      v: 1
    }));
  }

  // hand the frame to the retargeter (this also stops any baked action)
  PoseBridge.emit({
    t: performance.now() / 1000,
    source: 'live',
    space,                 // 'normalized_image' (default) or 'world'
    landmarks: L
  });
};

// 2) Helper if your teammate has pixel coords (x,y in pixels, z optional)
window.updatePose33Pixels = function updatePose33Pixels(pointsPx, width, height) {
  const L = pointsPx.map(p => {
    const x = p[0] / width;
    const y = p[1] / height;
    const z = (p[2] ?? 0);
    const v = (p[3] ?? 1);
    return { x, y, z, v };
  });
  window.updatePose33(L, 'normalized_image');
};

// 3) Stop live driving (so Idle/Walk buttons work again)
window.stopLivePose = function stopLivePose() {
  PoseBridge._mock(false); // ensure mock is off if it was running
  // Just stop calling updatePose33; the rig will stay on the last pose
};


function normalizeBlazePose(L, space = "world") {
  const toV3 = (p) => new THREE.Vector3(p.x, p.y, p.z);
  const hipL = toV3(L[23]);
  const hipR = toV3(L[24]);

  // Flip Y and Z if from image space (e.g., BlazePose normalized)
  if (space === "normalized_image") {
    for (const p of L) {
      p.y = -p.y;
      p.z = -p.z;
    }
  }

  const root = hipL.clone().add(hipR).multiplyScalar(0.5);
  const scale = hipL.distanceTo(hipR) || 1.0;

  const out = L.map(p => {
    const v = new THREE.Vector3(p.x, p.y, p.z);
    v.sub(root).divideScalar(scale);
    return { v, conf: (p.v ?? 1) };
  });

  return out; // returns [{v: THREE.Vector3, conf: number}, ...]
}


// --- Retarget mapping (BlazePose 33 -> Mixamo/YBot) ---
const DRIVEN = {
  "leftarm":      [11,13],
  "leftforearm":  [13,15],
  "rightarm":     [12,14],
  "rightforearm": [14,16],
  "leftupleg":    [23,25],
  "leftleg":      [25,27],
  "rightupleg":   [24,26],
  "rightleg":     [26,28],
};

const BIND = {}; // boneName -> {dir: Vector3, worldRot: Quaternion}

// Capture bind pose once (direction & world rotation)
function captureBind() {
  const a = new THREE.Vector3(), b = new THREE.Vector3(), q = new THREE.Quaternion();
  for (const name in DRIVEN) {
    const bone = boneMap[name];
    if (!bone || bone.children.length === 0) continue;
    bone.getWorldPosition(a);
    bone.children[0].getWorldPosition(b);
    const dir = b.clone().sub(a).normalize();
    bone.getWorldQuaternion(q);
    BIND[name] = { dir, worldRot: q.clone() };
  }
}

// Apply pose frame to skeleton
function applyBlazePoseFrame(frame) {
  if (!model) return;
  const L = normalizeBlazePose(frame.landmarks, frame.space);
  const seg = (i, j) => L[j].v.clone().sub(L[i].v).normalize();

  for (const name in DRIVEN) {
    const idx = DRIVEN[name];
    const bone = boneMap[name];
    const bind = BIND[name];
    if (!bone || !bind) continue;

    const targetDir = seg(idx[0], idx[1]);
    if (!isFinite(targetDir.x)) continue;

    const delta = new THREE.Quaternion().setFromUnitVectors(bind.dir, targetDir);
    const worldNew = delta.clone().multiply(bind.worldRot);

    const parentWorld = new THREE.Quaternion();
    bone.parent.getWorldQuaternion(parentWorld);
    const localNew = parentWorld.invert().multiply(worldNew);

    bone.quaternion.slerp(localNew, 0.5); // smooth
  }
}

// Subscribe to pose stream
PoseBridge.on((frame) => {
  if (currentAction) { currentAction.stop(); currentAction = null; }
  applyBlazePoseFrame(frame);
});



</script>

<!-- WebRTC camera tiles (from your relay) -->
<script>
  const webrtc_url = "{{ webrtcurl }}";
  const wrap = document.getElementById('videos-container');

  const v1 = document.createElement('iframe'); v1.src = `${webrtc_url}/view?cam=cam1`; v1.className='video';
  const v2 = document.createElement('iframe'); v2.src = `${webrtc_url}/view?cam=cam2`; v2.className='video';
  wrap.appendChild(v1); wrap.appendChild(v2);
</script>
{% endblock %}
